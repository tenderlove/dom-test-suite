<!--
Copyright (c) 2001 World Wide Web Consortium,
(Massachusetts Institute of Technology, Institut National de
Recherche en Informatique et en Automatique, Keio University). All
Rights Reserved. This program is distributed under the W3C's Software
Intellectual Property License. This program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See W3C License http://www.w3.org/Consortium/Legal/ for more details.
-->

<!--   
This transform generates ECMAScript source code from a language independent
test representation.

This transform requires an auxiliary file "interfaces.xml" that 
is produced by applying "extract.xsl" to the appropriate DOM
specificiation.


Usage:

saxon -o someTest.js someTest.xml test-to-ecmascript.xsl


-->



<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<!--  relative to transform   -->
	<xsl:param name="interfaces-docname">..\build\dom1-interfaces.xml</xsl:param>
    <xsl:param name="target-uri-base"/>


<xsl:output method="text"/>
<xsl:variable name="domspec" select="document($interfaces-docname)"/>

<xsl:template match="/">
	<xsl:apply-templates/>
</xsl:template>

<!-- 
       Copy any comments from the source file that have
       a copyright notice  

-->
<xsl:template match="comment()[contains(.,'Copyright')]">
/*
This ECMAScript source file was generated by test-to-java.xsl
and is a derived work from the source document.
The source document contained the following notice:

<xsl:value-of select="."/>
*/
</xsl:template>


<!--   produces JavaDoc for metadata elements   -->
<xsl:template match="*[local-name() = 'metadata']">
/**
* <xsl:value-of select="*[local-name()='description']"/><xsl:text>
</xsl:text>

<xsl:for-each select="*[local-name()='creator']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='contributor']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='subject']">
<xsl:text>* @see &lt;a href="</xsl:text><xsl:value-of select="@resource"/>"&gt;<xsl:value-of select="@resource"/><xsl:text>&lt;/a&gt;
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='source']">
<xsl:text>* @see &lt;a href="</xsl:text><xsl:value-of select="@resource"/>"&gt;<xsl:value-of select="@resource"/><xsl:text>&lt;/a&gt;
</xsl:text>
</xsl:for-each>
<xsl:text>*/
</xsl:text>
</xsl:template>


<xsl:template name="implCheck">
<xsl:variable name="implAttrs" select="*[local-name() = 'implementationAttribute']"/>
<xsl:if test="$implAttrs[@name = 'signed' and @value='false']">
	<xsl:text>      throw new DOMTestIncompatibleException("Test requires unsigned implementation");
</xsl:text>
</xsl:if>

<xsl:if test="$implAttrs[@name = 'hasNullString' and @value='false']">
	<xsl:text>      throw new DOMTestIncompatibleException("Test requires an implementation that does not support null strings");
</xsl:text>
</xsl:if>

<xsl:variable name="adjImplAttrs" select="$implAttrs[@name != 'signed' and @name != 'hasNullString']"/>
<xsl:choose>
	<xsl:when test="$adjImplAttrs">
		<xsl:text>
      var attrNames = new Array(</xsl:text>
      <xsl:value-of select="count($adjImplAttrs)"/>
      <xsl:text>);</xsl:text>
      <xsl:for-each select="$adjImplAttrs">
            <xsl:text>
      attrNames[</xsl:text>
            <xsl:value-of select="position() -1"/>
            <xsl:text>] = "</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>";</xsl:text>
      </xsl:for-each>
      <xsl:text>
      var attrValues = new Array(</xsl:text>
      <xsl:value-of select="count($adjImplAttrs)"/>
      <xsl:text>);</xsl:text>
      <xsl:for-each select="$adjImplAttrs">
            <xsl:text>
      attrValues[</xsl:text>
            <xsl:value-of select="position() -1"/>
            <xsl:text>] = </xsl:text>
            <xsl:value-of select="@value"/>
            <xsl:text>;</xsl:text>
       </xsl:for-each>
       <xsl:text>
      this.builder = factory.newDocumentBuilder(attrNames,attrValues);
</xsl:text>
	</xsl:when>
	<xsl:otherwise>
		<xsl:text>      this.builder = factory.newDocumentBuilder(null,null);
</xsl:text>
	</xsl:otherwise>
</xsl:choose>

<xsl:variable name="featureConditions" select="*[local-name() = 'hasFeature' and not(preceding-sibling::*[local-name()='var'])]"/>

<xsl:if test="$featureConditions">
    <xsl:text>      var domImpl = builder.getDOMImplementation();
</xsl:text>
    <xsl:for-each select="$featureConditions">
	    <xsl:text>      if(!domImpl.hasFeature(</xsl:text>
	    <xsl:value-of select="@feature"/>
	    <xsl:text>,</xsl:text>
	    <xsl:choose>
		    <xsl:when test="@version">
			    <xsl:value-of select="@version"/>
		    </xsl:when>
		    <xsl:otherwise>
			    <xsl:text>null</xsl:text>
		    </xsl:otherwise>
	    </xsl:choose>
	    <xsl:text>)) {
         throw new DOMTestIncompatibleException("</xsl:text>
        <xsl:value-of select="@feature"/>
	    <xsl:choose>
		    <xsl:when test="@version">
			    <xsl:text>","</xsl:text>
			    <xsl:value-of select="@version"/>
			    <xsl:text>"</xsl:text>
		    </xsl:when>
		    <xsl:otherwise>
			    <xsl:text>",null</xsl:text>
		    </xsl:otherwise>
	    </xsl:choose>
	    <xsl:text>);
      }
</xsl:text>
    </xsl:for-each>
</xsl:if>

</xsl:template>


<!--   when encountering a test   -->
<xsl:template match="*[local-name()='test']">

<!--  if there is a metadata child element then
          produce documentation comments    -->
    <xsl:apply-templates select="*[local-name()='metadata']"/>

    <xsl:text>
   function </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_runTest()  {
    </xsl:text>
<xsl:apply-templates mode="body"/>
    <xsl:text>
}

function </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>(factory) {
</xsl:text>
<xsl:call-template name="implCheck"/>
<xsl:text>
  this.runTest = </xsl:text>
  <xsl:value-of select="@name"/>
  <xsl:text>_runTest;
  this.targetURI = "</xsl:text>
  <xsl:value-of select="concat($target-uri-base,@name)"/>
  <xsl:text>";
}
</xsl:text>
</xsl:template>


<!--   when encountering a test   -->
<xsl:template match="*[local-name()='suite']">

<!--  if there is a metadata child element then
          produce documentation comments    -->
    <xsl:apply-templates select="*[local-name()='metadata']"/>
    <xsl:for-each select="*[local-name() = 'suite.member']">
        <xsl:apply-templates select="document(@href,.)/*"/>
    </xsl:for-each>
</xsl:template>



<!--    
    The following templates generate the body of the test function   
    
-->

<!--

    Implementation conditions and metadata elements produce nothing
	in the body of the test method

-->
<xsl:template match="*[local-name()='metadata']" mode="body"/>
<xsl:template match="*[local-name()='validating']" mode="body"/>
<xsl:template match="*[local-name()='coalescing']" mode="body"/>
<xsl:template match="*[local-name()='expandEntityReferences']" mode="body"/>
<xsl:template match="*[local-name()='ignoringElementContentWhitespace']" mode="body"/>
<xsl:template match="*[local-name()='ignoringComments']" mode="body"/>
<xsl:template match="*[local-name()='namespaceAware']" mode="body"/>
<xsl:template match="*[local-name()='signed']" mode="body"/>
<xsl:template match="*[local-name()='not']" mode="body"/>

<!--   this template generates code for the DOMString.length  -->
<xsl:template match="*[local-name()='length' and @interface='DOMString']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = </xsl:text>
    <xsl:value-of select="@obj"/>
    <xsl:text>.length;
      </xsl:text>
</xsl:template>


<!--   implementation attribute doesn't do anything in the body of the test  -->
<xsl:template match="*[local-name()='implementationAttribute']" mode="body"/>

<!--  
     hasFeature is a little unusual as both an implementation
	 condition and a DOM function.  This template should only
	 produce code when used as a DOM function.
-->
<xsl:template match="*[local-name()='hasFeature']" mode="body">
	<!--  if it doesn't have a var then 
			it is part of the implementation conditions and
			should not be produced in the body of the function  -->
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
		<!--  use @obj if provided, otherwise _framework   -->
		<xsl:if test="@obj">
			<xsl:value-of select="@obj"/>
			<xsl:text>.</xsl:text>
		</xsl:if>
		<xsl:text>hasFeature(</xsl:text>
		<xsl:value-of select="@feature"/>
		<xsl:text>,</xsl:text>
		<xsl:choose>
			<xsl:when test="@version">
				<xsl:value-of select="@version"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>null</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>);
</xsl:text>
	</xsl:if>
</xsl:template>


<!--    

	test framework constructs

-->
<xsl:template match="*[local-name()='var']" mode="body">
	<xsl:variable name="varname" select="@name"/>
	<xsl:text>var </xsl:text>
	<xsl:value-of select="$varname"/>
	<xsl:choose>
		<!--  explict value, just add it  -->
		<xsl:when test="@value"> = <xsl:apply-templates select="@value"/>;</xsl:when>
		<!--  member, allocate collection or list and populate it  -->
		<xsl:when test="@type='List' or @type='Collection'">
			<xsl:text> = new Array();
</xsl:text>
			<xsl:for-each select="*[local-name()='member']">
                <xsl:text>      </xsl:text>
     			<xsl:value-of select="$varname"/>
                <xsl:text>[</xsl:text>
                <xsl:value-of select="position()-1"/>
                <xsl:text>] = </xsl:text>
                <xsl:value-of select="text()"/>
                <xsl:text>;
</xsl:text>
			</xsl:for-each>
		</xsl:when>
		<!--  virtual method  -->
		<xsl:when test="*">
			<xsl:text> = new </xsl:text><xsl:apply-templates select="@type"/> {
				<xsl:apply-templates mode="anonInner"/>
			};
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='comment']" mode="body">
	<xsl:text>/* </xsl:text>
	<xsl:value-of select="."/>
	<xsl:text> */
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='wait']" mode="body">
	<xsl:text>wait(</xsl:text>
	<xsl:value-of select="@milliseconds"/>
	<xsl:text>);
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='append']" mode="body">
	<xsl:value-of select="@collection"/>
	<xsl:text>[</xsl:text>
    <xsl:value-of select="@collection"/>
    <xsl:text>.length] = </xsl:text>
	<xsl:value-of select="@obj"/>
    <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assign']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:choose>
		<xsl:when test="substring(@value,1,1) = '&quot;' or string(number(@value)) != 'NaN'">
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="var" select="@var"/>
			<xsl:variable name="value" select="@value"/>
			<xsl:call-template name="retval-cast">
				<xsl:with-param name="variable" select="@var"/>
				<xsl:with-param name="vartype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $var]/@type"/>
				<xsl:with-param name="rettype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $value]/@type"/>
			</xsl:call-template>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:otherwise>
	</xsl:choose>	
</xsl:template>

<xsl:template match="*[local-name()='increment']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> += </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='decrement']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> -= </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='plus']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> + </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='subtract']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> - </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='mult']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> * </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='divide']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='handleEvent']" mode="anonInner">
<xsl:text>boolean handleEvent(
		org.w3c.dom.events.EventListener listener, 
		org.w3c.dom.events.Events evt,
		org.w3c.dom.events.EventTarget currentTarget,
		Object userObj) {
</xsl:text>
	<xsl:apply-templates mode="body"/>
<xsl:text>}
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='implementation']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:if test="@obj">
		<xsl:value-of select="@obj"/>
		<xsl:text>.</xsl:text>
	</xsl:if>
	<xsl:text>implementation;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertTrue']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertTrue("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
            <xsl:text>	assertTrue("</xsl:text>
		    <xsl:value-of select="@id"/>
		    <xsl:text>",
      </xsl:text>
		    <xsl:apply-templates select="*[1]" mode="condition"/>
		    <xsl:text>);
</xsl:text>
	        <xsl:if test="count(*) &gt; 1">
                <xsl:text>
   if(</xsl:text>
                <xsl:apply-templates select="*[1]" mode="condition"/>
                <xsl:text>) {
</xsl:text>
		        <xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
                <xsl:text>
	}
</xsl:text>
            </xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='assertFalse']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(!</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			{
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:apply-templates select="*[1]" mode="condition"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="count(*) &gt; 1">
    if(!<xsl:apply-templates select="*[1]" mode="condition"/>) {
<xsl:apply-templates mode="body"/>
    }
</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='assertNull']" mode="body">
	<xsl:text>assertNull("</xsl:text>
	<xsl:value-of select="@id"/>",
	<xsl:value-of select="@actual"/>
	<xsl:text>);
    </xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> == null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
    </xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertNotNull']" mode="body">
	<xsl:text>assertNotNull("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> != null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSame']" mode="body">
	<xsl:text>assertSame("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@expected"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="count(*) &gt; 0">
		<xsl:text>if(same(</xsl:text>
		<xsl:value-of select="@expected"/>
		<xsl:text>,</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text>)) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertInstanceOf']" mode="body">
	<xsl:text>assertInstanceOf("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>","</xsl:text>
    <xsl:value-of select="@type"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@obj"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@obj"/>
		<xsl:text> instanceof </xsl:text>
		<xsl:call-template name="produce-type">
			<xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text>) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSize']" mode="body">
    <xsl:text>assertSize("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
	<xsl:value-of select="@size"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@collection"/>
	<xsl:text>);
</xsl:text>
    <xsl:if test="*">
   if(size(<xsl:value-of select="@collection"/>) == <xsl:value-of select="@size"/>) {
<xsl:apply-templates mode="body"/>
   }
</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertURIEquals']" mode="body">
    <xsl:text>assertURIEquals("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
    <xsl:choose>
        <xsl:when test="@scheme"><xsl:value-of select="@scheme"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@path"><xsl:value-of select="@path"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@host"><xsl:value-of select="@host"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@file"><xsl:value-of select="@file"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@query"><xsl:value-of select="@query"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@fragment"><xsl:value-of select="@fragment"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@isAbsolute=true">Boolean.TRUE,</xsl:when>
        <xsl:when test="@isAbsolute=false">Boolean.FALSE,</xsl:when>
        <xsl:when test="@isAbsolute"><xsl:value-of select="@isAbsolute"/></xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='assertEquals']" mode="body">
    <xsl:variable name="expected" select="@expected"/>
    <xsl:variable name="expectedType" select="ancestor::*[local-name() = 'test']/*[local-name() = 'var' and @name = $expected]/@type"/>
    <xsl:choose>
        <xsl:when test="$expectedType = 'Collection'">
            <xsl:call-template name="assertEquals">
                <xsl:with-param name="type">Collection</xsl:with-param>
            </xsl:call-template>
        </xsl:when>
        <xsl:when test="$expectedType = 'List'">
            <xsl:call-template name="assertEquals">
                <xsl:with-param name="type">List</xsl:with-param>
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="assertEquals">
                <xsl:with-param name="type"/>
            </xsl:call-template>
        </xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template name="assertEquals">
    <!--  either Equals, CollectionEquals or ListEquals  -->
    <xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase = 'true'">
            <xsl:text>      assertEquals</xsl:text>
            <xsl:value-of select="$type"/>
			<xsl:text>IgnoreCase("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>      if(equals</xsl:text>
                <xsl:value-of select="$type"/>
                <xsl:text>IgnoreCase(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text>,</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>)) {
      </xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>      }
      </xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>      assertEquals</xsl:text>
            <xsl:value-of select="$type"/>
            <xsl:text>("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
      </xsl:text>
			<xsl:if test="*">
				<xsl:text>if(equals</xsl:text>
                <xsl:value-of select="$type"/>
                <xsl:text>(</xsl:text>
				<xsl:value-of select="@expected"/>
                <xsl:text>,</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>)) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>      }
      </xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='assertNotEquals']" mode="body">
	<xsl:choose>
		<xsl:when test="@ignoreCase = 'true'">
			<xsl:text>assertNotEqualsIgnoreCase("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>,
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text>.toUpperCase() != </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>.toUpperCase()) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>assertNotEquals("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text> != </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='assertEventCount']" mode="body">
	<xsl:text>{
	var _tmpBool = true;
</xsl:text>
	<xsl:if test="@atCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getAtCount() == </xsl:text>
		<xsl:value-of select="@atCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@captureCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getCaptureCount() == </xsl:text>
		<xsl:value-of select="@captureCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@bubbleCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getBubbleCount() == </xsl:text>
		<xsl:value-of select="@BubbleCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@totalCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getTotalCount() == </xsl:text>
		<xsl:value-of select="@totalCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:text>assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",_tmpBool);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(_tmpBool) {
</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
	<xsl:text>}</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='if']" mode="body">
	if(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1 and local-name() != 'else']" mode="body"/>
	}
	<xsl:for-each select="*[local-name()='else']">
		else {
			<xsl:apply-templates mode="body"/>
		}
	</xsl:for-each>
</xsl:template>

<xsl:template match="*[local-name()='while']" mode="body">
    while(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
	}
</xsl:template>

<xsl:template match="*[local-name()='for-each']" mode="body">
    <xsl:text>for(var _index = 0; _index &lt; </xsl:text>
	<xsl:variable name="varname" select="@collection"/>
	<xsl:value-of select="@collection"/>
	<xsl:text>.length; _index++) {
      </xsl:text>
	<xsl:value-of select="@member"/>
	<xsl:text> = </xsl:text>
    <xsl:value-of select="@collection"/>
    <xsl:variable name="collType" select="ancestor::*[local-name() = 'test']/*[local-name() = 'var' and @name=$varname]/@type"/>
    <xsl:choose>
        <xsl:when test="$collType = 'List' or $collType='Collection'">
            <xsl:text>[_index];
      </xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>.item(_index);
      </xsl:text>
        </xsl:otherwise>
    </xsl:choose>
	<xsl:apply-templates select="*" mode="body"/>
	}
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.setUserObj']" mode="body">
	<xsl:value-of select="@obj"/>.setUserObj(<xsl:value-of select="@userObj"/>);
</xsl:template>

<xsl:template match="*[local-name()='EventMonitor.getAtEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getAtEvents();
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.getCaptureEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getCaptureEvents();
</xsl:template>

<xsl:template match="*[local-name()='EventMonitor.getBubbleEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getBubbleEvents();
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.getAllEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getAddEvents();
</xsl:template>

<xsl:template name="produce-type">
	<xsl:param name="type"/>
    <xsl:text>var</xsl:text>
</xsl:template>

<xsl:template match="@type">
	<xsl:call-template name="produce-type">
		<xsl:with-param name="type" select="."/>
	</xsl:call-template>
</xsl:template>

<!--  this builds an override for the handleEvent method of EventMonitor  -->
<xsl:template match="*[local-name()='handleEvent']" mode="anonInner">
function handleEvent(listener, event, userObj) {
<xsl:apply-templates mode="body"/>
}
</xsl:template>

<xsl:template match="*[local-name()='load']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = this.builder.load("</xsl:text>
	<xsl:value-of select="@href"/>
	<xsl:text>",</xsl:text>
    <xsl:value-of select="@willBeModified"/>
	<xsl:text>);
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertDOMException']" mode="body">
    <xsl:text>
	{
		var success = false;
		try {
            </xsl:text>
	<xsl:apply-templates select="*/*" mode="body"/>
    <xsl:text>  }
		catch(ex) {            
			success = this.builder.isDOMExceptionCode(ex,</xsl:text>
    <xsl:variable name="excode" select="local-name(*)"/>
	<xsl:value-of select="$domspec/library/group/constant[@name = $excode]/@value"/>
	<xsl:text>);
		}
		assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",success);
	}
</xsl:text>
</xsl:template>

<xsl:template match="text()" mode="body"/>

<xsl:template match="*" mode="body">
	<xsl:variable name="feature" select="local-name(.)"/>
	<xsl:variable name="method" select="$domspec/library/interface/method[@name = $feature]"/>
	<xsl:choose>
		<xsl:when test="$method">
			<xsl:call-template name="produce-method">
				<xsl:with-param name="method" select="$method"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="attribute" select="$domspec/library/interface/attribute[@name = $feature]"/>
			<xsl:choose>
				<xsl:when test="$attribute">
					<xsl:call-template name="produce-attribute"/>
				</xsl:when>

				<xsl:otherwise>
					<xsl:message>Unrecognized element <xsl:value-of select="local-name(.)"/></xsl:message>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template name="cast">
	<xsl:param name="var"/>
	<xsl:param name="vartype"/>
	<xsl:param name="reqtype"/>
</xsl:template>


<xsl:template name="retval-cast">
	<xsl:param name="vartype"/>
	<xsl:param name="rettype"/>
	<xsl:param name="variable"/>
</xsl:template>


<xsl:template name="build-accessor">
	<xsl:param name="prefix"/>
	<xsl:param name="attribute"/>
	<xsl:value-of select="$attribute"/>
</xsl:template>

<xsl:template name="produce-param">
	<xsl:param name="value"/>
	<xsl:param name="reqtype"/>
    <xsl:value-of select="$value"/>
</xsl:template>

<xsl:template name="produce-specific-attribute">
	<xsl:param name="attribute"/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:if test="@value">
        <xsl:value-of select="$obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@value"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:variable name="var" select="@var"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
</xsl:template>


<xsl:template name="produce-specific-method">
	<xsl:param name="method"/>
	<xsl:variable name="current" select="."/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:variable name="var" select="@var"/>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
	</xsl:if>
    <xsl:value-of select="@obj"/>
	<xsl:text>.</xsl:text>
	<xsl:value-of select="$method/@name"/>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="$method/parameters/param">
		<xsl:if test="position() &gt; 1">,</xsl:if>
		<xsl:value-of select="$current/@*[name() = current()/@name]"/>
	</xsl:for-each>
	<xsl:text>);</xsl:text>
</xsl:template>



<xsl:template name="produce-attribute">
	<xsl:variable name="attribName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface[@name = $interface]/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>

<xsl:template name="produce-method">
	<xsl:variable name="methodName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$domspec/library/interface[@name = $interface]/method[@name = $methodName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="methods" select="$domspec/library/interface/method[@name = $methodName]"/>
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$methods[1]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='not']" mode="condition">
	!(<xsl:apply-templates mode="condition"/>)
</xsl:template>

<xsl:template match="*[local-name()='and']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> &amp;&amp; </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='or']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> || </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='xor']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> ^ </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>


<xsl:template match="*[local-name()='isTrue']" mode="condition">
	<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='isFalse']" mode="condition">
	!<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='same']" mode="condition">
	same(<xsl:value-of select="@expected"/>,<xsl:value-of select="@actual"/>)
</xsl:template>

<xsl:template match="*[local-name()='equals']" mode="condition">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="@expected"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase() == </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text> == </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase())</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='notEquals']" mode="condition">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="@expected"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase() != </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text> != </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase())</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='less']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt; <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='lessOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt;= <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greater']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt; <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greaterOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt;= <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='isNull']" mode="condition">
	(<xsl:value-of select="@obj"/> == null)
</xsl:template>


<xsl:template match="*[local-name()='notNull']" mode="condition">
	(<xsl:value-of select="@obj"/> != null)
</xsl:template>

<xsl:template match="*[local-name()='instanceOf']" mode="condition">
	(<xsl:value-of select="@obj"/> instanceOf <xsl:value-of select="@type"/>)
</xsl:template>


<xsl:template match="*[local-name()='hasSize']" mode="condition">
	(<xsl:value-of select="@obj"/>.length == <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='implementationAttribute']" mode="condition">
	<xsl:text>(this.builder.getImplementationAttribute("</xsl:text>
	<xsl:value-of select="@name"/>
    <xsl:text>") == </xsl:text>
    <xsl:value-of select="@value"/>
    <xsl:text>)</xsl:text>
</xsl:template>



<xsl:template match="*[local-name()='hasFeature']" mode="condition">
	<xsl:if test="@obj">
		<xsl:value-of select="@obj"/>
		<xsl:text>.</xsl:text>
	</xsl:if>
	<xsl:text>hasFeature(</xsl:text>
	<xsl:value-of select="@feature"/>,
	<xsl:choose>
		<xsl:when test="@version">
			<xsl:value-of select="@version"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>""</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>)</xsl:text>
</xsl:template>

</xsl:stylesheet>
