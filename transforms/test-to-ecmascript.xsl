<!--
Copyright (c) 2001 World Wide Web Consortium,
(Massachusetts Institute of Technology, Institut National de
Recherche en Informatique et en Automatique, Keio University). All
Rights Reserved. This program is distributed under the W3C's Software
Intellectual Property License. This program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See W3C License http://www.w3.org/Consortium/Legal/ for more details.
-->

<!--   
This transform generates ECMAScript source code from a language independent
test representation.

This transform requires an auxiliary file "interfaces.xml" that 
is produced by applying "extract.xsl" to the appropriate DOM
specificiation.


Usage:

saxon -o someTest.js someTest.xml test-to-ecmascript.xsl


-->

<!--
$Log: test-to-ecmascript.xsl,v $
Revision 1.5  2001-08-30 08:30:18  dom-ts-4
Added metadata and Software licence (dropped in earlier processing) to test
Enhanced test-matrix.xsl

Revision 1.4  2001/08/23 08:01:49  dom-ts-4
Test fixups for ignoring whitespace, et al

Revision 1.3  2001/08/22 22:12:50  dom-ts-4
Now passing all tests with default settings

Revision 1.2  2001/08/15 04:44:03  dom-ts-4
Added dom1-gen-ecmascript target to build.xml
Minor fixes to test-to-java.xsl and test-to-ecmascript.xsl

Revision 1.1  2001/08/14 18:49:35  dom-ts-4
Changed location of resource files
Remove spurious required ID's from DTD
Added xmlns:xsi and xsi:schema location to DTD
Removed package and targetURI attributes from Schema/DTD

-->


<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<!--  relative to transform   -->
	<xsl:param name="interfaces-docname"/>
    <xsl:param name="target-uri-base"/>


<xsl:output method="text"/>
<xsl:variable name="domspec" select="document($interfaces-docname)"/>

<xsl:template match="/">
	<xsl:apply-templates/>
</xsl:template>

<!-- 
       Copy any comments from the source file that have
       a copyright notice  

-->
<xsl:template match="comment()[contains(.,'Copyright')]">
/*
This ECMAScript source file was generated by test-to-java.xsl
and is a derived work from the source document.
The source document contained the following notice:

<xsl:value-of select="."/>
*/
</xsl:template>


<!--   produces JavaDoc for metadata elements   -->
<xsl:template match="*[local-name() = 'metadata']">
/**
* <xsl:value-of select="*[local-name()='description']"/><xsl:text>
</xsl:text>

<xsl:for-each select="*[local-name()='creator']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='contributor']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='subject']">
<xsl:text>* @see &lt;a href="</xsl:text><xsl:value-of select="@resource"/>"&gt;<xsl:value-of select="@resource"/><xsl:text>&lt;/a&gt;
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='source']">
<xsl:text>* @see &lt;a href="</xsl:text><xsl:value-of select="@resource"/>"&gt;<xsl:value-of select="@resource"/><xsl:text>&lt;/a&gt;
</xsl:text>
</xsl:for-each>
<xsl:text>*/
</xsl:text>
</xsl:template>


<xsl:template name="implCheck">
<xsl:variable name="implAttrs" select="*[local-name() = 'implementationAttribute']"/>
<xsl:if test="$implAttrs[@name = 'signed' and @value='false']">
	<xsl:text>      throw new DOMTestIncompatibleException("Test requires unsigned implementation");
</xsl:text>
</xsl:if>

<xsl:if test="$implAttrs[@name = 'hasNullString' and @value='false']">
	<xsl:text>      throw new DOMTestIncompatibleException("Test requires an implementation that does not support null strings");
</xsl:text>
</xsl:if>

<xsl:variable name="adjImplAttrs" select="$implAttrs[@name != 'signed' and @name != 'hasNullString']"/>
<xsl:choose>
	<xsl:when test="$adjImplAttrs">
		<xsl:text>
      var attrNames = new Array(</xsl:text>
      <xsl:value-of select="count($adjImplAttrs)"/>
      <xsl:text>);</xsl:text>
      <xsl:for-each select="$adjImplAttrs">
            <xsl:text>
      attrNames[</xsl:text>
            <xsl:value-of select="position() -1"/>
            <xsl:text>] = "</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>";</xsl:text>
      </xsl:for-each>
      <xsl:text>
      var attrValues = new Array(</xsl:text>
      <xsl:value-of select="count($adjImplAttrs)"/>
      <xsl:text>);</xsl:text>
      <xsl:for-each select="$adjImplAttrs">
            <xsl:text>
      attrValues[</xsl:text>
            <xsl:value-of select="position() -1"/>
            <xsl:text>] = </xsl:text>
            <xsl:value-of select="@value"/>
            <xsl:text>;</xsl:text>
       </xsl:for-each>
       <xsl:text>
      var myFactory = factory.newInstance(attrNames,attrValues);
</xsl:text>
	</xsl:when>
	<xsl:otherwise>
		<xsl:text>      var myFactory = factory.newInstance();
</xsl:text>
	</xsl:otherwise>
</xsl:choose>

<xsl:text>
      var builder = myFactory.newDocumentBuilder();
</xsl:text>

<xsl:variable name="featureConditions" select="*[local-name() = 'hasFeature' and not(preceding-sibling::*[local-name()='var'])]"/>

<xsl:if test="$featureConditions">
    <xsl:text>      var domImpl = builder.getDOMImplementation();
</xsl:text>
    <xsl:for-each select="$featureConditions">
	    <xsl:text>      if(!domImpl.hasFeature("</xsl:text>
	    <xsl:value-of select="@feature"/>
	    <xsl:text>",</xsl:text>
	    <xsl:choose>
		    <xsl:when test="@version">
			    <xsl:text>"</xsl:text>
			    <xsl:value-of select="@version"/>
			    <xsl:text>"</xsl:text>
		    </xsl:when>
		    <xsl:otherwise>
			    <xsl:text>""</xsl:text>
		    </xsl:otherwise>
	    </xsl:choose>
	    <xsl:text>)) {
         throw new DOMTestIncompatibleException("</xsl:text>
        <xsl:value-of select="@feature"/>
	    <xsl:choose>
		    <xsl:when test="@version">
			    <xsl:text>","</xsl:text>
			    <xsl:value-of select="@version"/>
			    <xsl:text>"</xsl:text>
		    </xsl:when>
		    <xsl:otherwise>
			    <xsl:text>",null</xsl:text>
		    </xsl:otherwise>
	    </xsl:choose>
	    <xsl:text>);
      }
</xsl:text>
    </xsl:for-each>
</xsl:if>

</xsl:template>


<!--   when encountering a test   -->
<xsl:template match="*[local-name()='test']">

<!--  if there is a metadata child element then
          produce documentation comments    -->
    <xsl:apply-templates select="*[local-name()='metadata']"/>

    <xsl:text>
   function </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_runTest()  {
    </xsl:text>
<xsl:apply-templates mode="body"/>
    <xsl:text>
}

function </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>(factory) {
</xsl:text>
<xsl:call-template name="implCheck"/>
<xsl:text>
  this.factory = myFactory;
  this.builder = builder;
  this.runTest = </xsl:text>
  <xsl:value-of select="@name"/>
  <xsl:text>_runTest;
  this.targetURI = "</xsl:text>
  <xsl:value-of select="concat($target-uri-base,@name)"/>
  <xsl:text>";
}
</xsl:text>
</xsl:template>


<!--   when encountering a test   -->
<xsl:template match="*[local-name()='suite']">
<xsl:choose>
	<xsl:when test="@package">
package <xsl:value-of select="@package"/>;
	</xsl:when>
	<xsl:otherwise>
package org.w3c.domts.level1.core;
	</xsl:otherwise>
</xsl:choose>

import org.w3c.dom.*;
<xsl:if test="*[local-name() = 'hasFeature' and @feature='Events']">
import org.w3c.dom.events;
</xsl:if>
import org.w3c.domts.*;
import javax.xml.parsers.*;
import java.util.*;

<!--  if there is a metadata child element then
          produce documentation comments    -->
<xsl:apply-templates select="*[local-name()='metadata']"/>
    <xsl:text>public class </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text> extends DOMTestSuite {

   public </xsl:text>
    <xsl:value-of select="@name"/>
   	<xsl:text>(DOMTestDocumentBuilderFactory factory) throws Exception {
</xsl:text>

    <xsl:call-template name="implCheck"/>
    <xsl:text>
      setFactory(factory);
   }

   public void build(DOMTestSink sink) {
</xsl:text>
    <xsl:for-each select="*[local-name() = 'suite.member']">
        <xsl:variable name="testDef" select="document(@href,.)/*"/>
         <xsl:text>      sink.addTest(</xsl:text>
         <xsl:if test="$testDef/@package">
            <xsl:value-of select="$testDef/@package"/>
            <xsl:text>.</xsl:text>
         </xsl:if>
         <xsl:value-of select="$testDef/@name"/>
         <xsl:text>.class);
</xsl:text>
    </xsl:for-each>
   }
   public String getTargetURI() {
      return "<xsl:value-of select="concat($target-uri-base,@name)"/>";
   }
}
</xsl:template>



<!--    
    The following templates generate the body of the test function   
    
-->

<!--

    Implementation conditions and metadata elements produce nothing
	in the body of the test method

-->
<xsl:template match="*[local-name()='metadata']" mode="body"/>
<xsl:template match="*[local-name()='validating']" mode="body"/>
<xsl:template match="*[local-name()='coalescing']" mode="body"/>
<xsl:template match="*[local-name()='expandEntityReferences']" mode="body"/>
<xsl:template match="*[local-name()='ignoringElementContentWhitespace']" mode="body"/>
<xsl:template match="*[local-name()='ignoringComments']" mode="body"/>
<xsl:template match="*[local-name()='namespaceAware']" mode="body"/>
<xsl:template match="*[local-name()='signed']" mode="body"/>
<xsl:template match="*[local-name()='not']" mode="body"/>


<!--   implementation attribute doesn't do anything in the body of the test  -->
<xsl:template match="*[local-name()='implementationAttribute']" mode="body"/>

<!--  
     hasFeature is a little unusual as both an implementation
	 condition and a DOM function.  This template should only
	 produce code when used as a DOM function.
-->
<xsl:template match="*[local-name()='hasFeature']" mode="body">
	<!--  if it doesn't have a var then 
			it is part of the implementation conditions and
			should not be produced in the body of the function  -->
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
		<!--  use @obj if provided, otherwise _framework   -->
		<xsl:if test="@obj">
			<xsl:value-of select="@obj"/>
			<xsl:text>.</xsl:text>
		</xsl:if>
		<xsl:text>hasFeature("</xsl:text>
		<xsl:value-of select="@feature"/>
		<xsl:text>",</xsl:text>
		<xsl:choose>
			<xsl:when test="@version">
				<xsl:text>"</xsl:text><xsl:value-of select="@version"/><xsl:text>"</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>""</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>);
</xsl:text>
	</xsl:if>
</xsl:template>


<!--    

	test framework constructs

-->
<xsl:template match="*[local-name()='var']" mode="body">
	<xsl:variable name="varname" select="@name"/>
	<xsl:text>var </xsl:text>
	<xsl:value-of select="$varname"/>
	<xsl:choose>
		<!--  explict value, just add it  -->
		<xsl:when test="@value"> = <xsl:apply-templates select="@value"/>;</xsl:when>
		<!--  member, allocate collection or list and populate it  -->
		<xsl:when test="@type='List' or @type='Collection'">
			<xsl:text> = new Array();
</xsl:text>
			<xsl:for-each select="*[local-name()='member']">
     			<xsl:value-of select="$varname"/>
                <xsl:text>[</xsl:text>
                <xsl:value-of select="position()"/>
                <xsl:text>] = </xsl:text>
                <xsl:value-of select="text()"/>
                <xsl:text>];
</xsl:text>
			</xsl:for-each>
		</xsl:when>
		<!--  virtual method  -->
		<xsl:when test="*">
			<xsl:text> = new </xsl:text><xsl:apply-templates select="@type"/> {
				<xsl:apply-templates mode="anonInner"/>
			};
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='comment']" mode="body">
	<xsl:text>/* </xsl:text>
	<xsl:value-of select="."/>
	<xsl:text> */
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='wait']" mode="body">
	<xsl:text>wait(</xsl:text>
	<xsl:value-of select="@milliseconds"/>
	<xsl:text>);
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='append']" mode="body">
	<xsl:value-of select="@collection"/>
	<xsl:text>[</xsl:text>
    <xsl:value-of select="@collection"/>
    <xsl:text>.length] = </xsl:text>
	<xsl:value-of select="@obj"/>
    <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assign']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:choose>
		<xsl:when test="substring(@value,1,1) = '&quot;' or string(number(@value)) != 'NaN'">
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="var" select="@var"/>
			<xsl:variable name="value" select="@value"/>
			<xsl:call-template name="retval-cast">
				<xsl:with-param name="variable" select="@var"/>
				<xsl:with-param name="vartype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $var]/@type"/>
				<xsl:with-param name="rettype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $value]/@type"/>
			</xsl:call-template>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:otherwise>
	</xsl:choose>	
</xsl:template>

<xsl:template match="*[local-name()='increment']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> += </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='decrement']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> -= </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='plus']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> + </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='subtract']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> - </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='mult']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> * </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='divide']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='handleEvent']" mode="anonInner">
<xsl:text>boolean handleEvent(
		org.w3c.dom.events.EventListener listener, 
		org.w3c.dom.events.Events evt,
		org.w3c.dom.events.EventTarget currentTarget,
		Object userObj) {
</xsl:text>
	<xsl:apply-templates mode="body"/>
<xsl:text>}
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='implementation']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:if test="@obj">
		<xsl:value-of select="@obj"/>
		<xsl:text>.</xsl:text>
	</xsl:if>
	<xsl:text>implementation;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertTrue']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertTrue("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
            <xsl:text>	assertTrue("</xsl:text>
		    <xsl:value-of select="@id"/>
		    <xsl:text>",
      </xsl:text>
		    <xsl:apply-templates select="*[1]" mode="condition"/>
		    <xsl:text>);
</xsl:text>
	        <xsl:if test="count(*) &gt; 1">
                <xsl:text>
   if(</xsl:text>
                <xsl:apply-templates select="*[1]" mode="condition"/>
                <xsl:text>) {
</xsl:text>
		        <xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
                <xsl:text>
	}
</xsl:text>
            </xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='assertFalse']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(!</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			{
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>",
			<xsl:apply-templates select="*[1]" mode="condition"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="count(*) &gt; 1">
    if(!<xsl:apply-templates select="*[1]" mode="condition"/>) {
<xsl:apply-templates mode="body"/>
    }
</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='assertNull']" mode="body">
	<xsl:text>assertNull("</xsl:text>
	<xsl:value-of select="@id"/>",
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> == null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertNotNull']" mode="body">
	<xsl:text>assertNotNull("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> != null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSame']" mode="body">
	<xsl:text>assertSame("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@expected"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="count(*) &gt; 0">
		<xsl:text>if(same(</xsl:text>
		<xsl:value-of select="@expected"/>
		<xsl:text>,</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text>)) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertInstanceOf']" mode="body">
	<xsl:text>assertInstanceOf("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>","</xsl:text>
	<xsl:call-template name="produce-type">
		<xsl:with-param name="type" select="@type"/>
	</xsl:call-template>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@obj"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@obj"/>
		<xsl:text> instanceof </xsl:text>
		<xsl:call-template name="produce-type">
			<xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text>) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSize']" mode="body">
    <xsl:text>assertSize("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
	<xsl:value-of select="@size"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@collection"/>
	<xsl:text>);
</xsl:text>
    <xsl:if test="*">
   if(size(<xsl:value-of select="@collection"/>) == <xsl:value-of select="@size"/>) {
<xsl:apply-templates mode="body"/>
   }
</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertEquals']" mode="body">
	<xsl:choose>
		<xsl:when test="@ignoreCase = 'true'">
			<xsl:text>assertEqualsIgnoreCase("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>      if(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text>.toUpperCase() == </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>.toUpperCase()) {
      </xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>      }
      </xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>assertEquals("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
      </xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@expected"/>
                <xsl:text> == </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>      }
      </xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='assertNotEquals']" mode="body">
	<xsl:choose>
		<xsl:when test="@ignoreCase = 'true'">
			<xsl:text>assertNotEqualsIgnoreCase("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>,
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text>.toUpperCase() != </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>.toUpperCase()) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>assertNotEquals("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>,</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@expected"/>
				<xsl:text> != </xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='assertEventCount']" mode="body">
	<xsl:text>{
	var _tmpBool = true;
</xsl:text>
	<xsl:if test="@atCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getAtCount() == </xsl:text>
		<xsl:value-of select="@atCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@captureCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getCaptureCount() == </xsl:text>
		<xsl:value-of select="@captureCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@bubbleCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getBubbleCount() == </xsl:text>
		<xsl:value-of select="@BubbleCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@totalCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getTotalCount() == </xsl:text>
		<xsl:value-of select="@totalCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:text>assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",_tmpBool);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(_tmpBool) {
</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
	<xsl:text>}</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='if']" mode="body">
	if(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1 and local-name() != 'else']" mode="body"/>
	}
	<xsl:for-each select="*[local-name()='else']">
		else {
			<xsl:apply-templates mode="body"/>
		}
	</xsl:for-each>
</xsl:template>

<xsl:template match="*[local-name()='while']" mode="body">
    while(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
	}
</xsl:template>

<xsl:template match="*[local-name()='for-each']" mode="body">
    <xsl:text>for(var _index = 0; _index &lt; </xsl:text>
	<xsl:variable name="varname" select="@collection"/>
	<xsl:value-of select="@collection"/>
	<xsl:text>.length; _index++) {
</xsl:text>
	<xsl:value-of select="@member"/> = <xsl:value-of select="@collection"/>[_index];
	<xsl:apply-templates select="*" mode="body"/>
	}
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.setUserObj']" mode="body">
	<xsl:value-of select="@obj"/>.setUserObj(<xsl:value-of select="@userObj"/>);
</xsl:template>

<xsl:template match="*[local-name()='EventMonitor.getAtEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getAtEvents();
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.getCaptureEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getCaptureEvents();
</xsl:template>

<xsl:template match="*[local-name()='EventMonitor.getBubbleEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getBubbleEvents();
</xsl:template>


<xsl:template match="*[local-name()='EventMonitor.getAllEvents']" mode="body">
	<xsl:value-of select="@var"/> = <xsl:value-of select="@monitor"/>.getAddEvents();
</xsl:template>

<xsl:template name="produce-type">
	<xsl:param name="type"/>
    <xsl:text>var</xsl:text>
</xsl:template>

<xsl:template match="@type">
	<xsl:call-template name="produce-type">
		<xsl:with-param name="type" select="."/>
	</xsl:call-template>
</xsl:template>

<!--  this builds an override for the handleEvent method of EventMonitor  -->
<xsl:template match="*[local-name()='handleEvent']" mode="anonInner">
function handleEvent(listener, event, userObj) {
<xsl:apply-templates mode="body"/>
}
</xsl:template>

<xsl:template match="*[local-name()='load']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = load(this,"</xsl:text>
	<xsl:value-of select="@href"/>
	<xsl:text>");
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertDOMException']" mode="body">
	{
		var success = false;
		try {
			<xsl:apply-templates select="*/*" mode="body"/>
		}
		catch(ex) {
			success = (ex.code == <xsl:value-of select="name(*)"/>);
		}
		assertTrue("<xsl:value-of select="@id"/>",success);
	}
</xsl:template>

<xsl:template match="text()" mode="body"/>

<xsl:template match="*" mode="body">
	<xsl:variable name="feature" select="local-name(.)"/>
	<xsl:variable name="method" select="$domspec/library/interface/method[@name = $feature]"/>
	<xsl:choose>
		<xsl:when test="$method">
			<xsl:call-template name="produce-method">
				<xsl:with-param name="method" select="$method"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="attribute" select="$domspec/library/interface/attribute[@name = $feature]"/>
			<xsl:choose>
				<xsl:when test="$attribute">
					<xsl:call-template name="produce-attribute"/>
				</xsl:when>

				<xsl:otherwise>
					<xsl:message>Unrecognized element <xsl:value-of select="local-name(.)"/></xsl:message>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template name="cast">
	<xsl:param name="var"/>
	<xsl:param name="vartype"/>
	<xsl:param name="reqtype"/>
</xsl:template>


<xsl:template name="retval-cast">
	<xsl:param name="vartype"/>
	<xsl:param name="rettype"/>
	<xsl:param name="variable"/>
</xsl:template>


<xsl:template name="build-accessor">
	<xsl:param name="prefix"/>
	<xsl:param name="attribute"/>
	<xsl:value-of select="$attribute"/>
</xsl:template>

<xsl:template name="produce-param">
	<xsl:param name="value"/>
	<xsl:param name="reqtype"/>
    <xsl:value-of select="$value"/>
</xsl:template>

<xsl:template name="produce-specific-attribute">
	<xsl:param name="attribute"/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:if test="@value">
        <xsl:value-of select="$obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@value"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:variable name="var" select="@var"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
</xsl:template>


<xsl:template name="produce-specific-method">
	<xsl:param name="method"/>
	<xsl:variable name="current" select="."/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:variable name="var" select="@var"/>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
	</xsl:if>
    <xsl:value-of select="@obj"/>
	<xsl:text>.</xsl:text>
	<xsl:value-of select="$method/@name"/>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="$method/parameters/param">
		<xsl:if test="position() &gt; 1">,</xsl:if>
		<xsl:value-of select="$current/@*[name() = current()/@name]"/>
	</xsl:for-each>
	<xsl:text>);</xsl:text>
</xsl:template>



<xsl:template name="produce-attribute">
	<xsl:variable name="attribName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface[@name = $interface]/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>

<xsl:template name="produce-method">
	<xsl:variable name="methodName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$domspec/library/interface[@name = $interface]/method[@name = $methodName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="methods" select="$domspec/library/interface/method[@name = $methodName]"/>
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$methods[1]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='not']" mode="condition">
	!(<xsl:apply-templates mode="condition"/>)
</xsl:template>

<xsl:template match="*[local-name()='and']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> &amp; </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='or']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> | </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='xor']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> ^ </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>


<xsl:template match="*[local-name()='isTrue']" mode="condition">
	<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='isFalse']" mode="condition">
	!<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='same']" mode="condition">
	same(<xsl:value-of select="@expected"/>,<xsl:value-of select="@actual"/>)
</xsl:template>

<xsl:template match="*[local-name()='equals']" mode="condition">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="@expected"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase() == </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text> == </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase())</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='notEquals']" mode="condition">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="@expected"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase() != </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text> != </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:choose>
		<xsl:when test="@ignoreCase='true'">
			<xsl:text>.toUpperCase())</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='less']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt; <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='lessOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt;= <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greater']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt; <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greaterOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt;= <xsl:value-of select="expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='isNull']" mode="condition">
	(<xsl:value-of select="@obj"/> == null)
</xsl:template>


<xsl:template match="*[local-name()='notNull']" mode="condition">
	(<xsl:value-of select="@obj"/> != null)
</xsl:template>

<xsl:template match="*[local-name()='instanceOf']" mode="condition">
	(<xsl:value-of select="@obj"/> instanceOf <xsl:value-of select="@type"/>)
</xsl:template>


<xsl:template match="*[local-name()='hasSize']" mode="condition">
	(<xsl:value-of select="@obj"/>.length == <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='implementationAttribute']" mode="condition">
	<xsl:text>(getImplementationAttribute("</xsl:text>
	<xsl:value-of select="@name"/>
    <xsl:text>") == </xsl:text>
    <xsl:value-of select="@value"/>
    <xsl:text>)</xsl:text>
</xsl:template>



<xsl:template match="*[local-name()='hasFeature']" mode="condition">
	<xsl:if test="@obj">
		<xsl:value-of select="@obj"/>
		<xsl:text>.</xsl:text>
	</xsl:if>
	<xsl:text>hasFeature(</xsl:text>
	<xsl:value-of select="@feature"/>,
	<xsl:choose>
		<xsl:when test="@version">
			<xsl:value-of select="@version"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>""</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>)</xsl:text>
</xsl:template>

</xsl:stylesheet>
